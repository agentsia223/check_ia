# AI Analysis Pipeline

Check-IA uses a multi-stage pipeline that combines several AI models for thorough fact verification.

## Text Verification Pipeline

![AI Verification Pipeline](../assets/images/ai-pipeline.png)

### Stage 1: Translation

French text is translated to English using `deep-translator` (Google Translate backend). This is necessary because the RoBERTa model was trained on English text.

**Service:** `core/services/deep_translator.py`

### Stage 2: RoBERTa Classification

The translated text is fed into a pre-trained RoBERTa model (`hamzab/roberta-fake-news-classification`) for an initial true/false classification with a confidence score. This provides a baseline signal.

**Service:** `core/services/ai_analysis.py`

### Stage 3: Source Search (Perplexity)

The original French text is sent to Perplexity's Sonar Pro model to find relevant web sources, citations, and contextual information. This step provides the evidence base for the final analysis.

**Service:** `core/services/perplexity_search.py`

### Stage 4: LLM Analysis (GPT-4o-mini)

All gathered evidence — the RoBERTa classification, Perplexity sources, and verification content — is synthesized by GPT-4o-mini (via OpenRouter) into a structured final verdict with:

- **Status**: True (VRAIE), False (FAUSSE), or Undetermined (INDETERMINEE)
- **Explanation**: A detailed, sourced explanation in French
- **Key sources**: The most relevant sources used

**Service:** `core/services/llm.py`

## Image Verification

### Content Verification

Users upload an image along with a claim about it. Gemini 2.0 Flash analyzes the image and determines whether it supports the claim.

### AI Image Detection

Users upload an image to detect whether it was generated by AI. This uses a combination of pixel-level analysis and Gemini 2.0 Flash vision capabilities.

**Services:** `core/services/image_verification.py`, `core/services/pixel_analyzer.py`

## Async Processing

All analysis tasks run asynchronously through Celery:

1. User submits a request → API creates a record with status "en cours" (in progress)
2. A Celery task is dispatched → API returns immediately with a task ID
3. The frontend polls `GET /api/task-status/<task_id>/` for results
4. When complete, the task updates the database record with results

**Tasks:** `core/tasks.py`
